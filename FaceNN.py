# -*- coding: utf-8 -*-
"""FIPERFINAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J-32TNEbTGOWFieciCIdxqhCYKvOjS-k
"""

from keras.models import Sequential
from keras.layers import Dense
import pandas as pd
import numpy as np
import io
import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import Flatten
from keras.layers.convolutional import Convolution2D
from keras.layers.convolutional import MaxPooling2D 
from keras.utils import np_utils
from numpy import array
#from keras import backend as K
#from keras.regularizers import l1, activity_l1
from keras.callbacks import ModelCheckpoint

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix

import itertools
# %matplotlib inline
import matplotlib.pyplot as plt
import matplotlib.cm as cm

import re
from math import *

from flask import Flask
from flask import request
app = Flask(__name__)

db=pd.read_csv('FiperFIN.csv')
print(db)

db['avgx']=[(float(i)+float(j))*0.5 for i, j in zip(db['Right eye x'], db['Left eye x'])]
db['avgy']=[(float(i)+float(j))*0.5 for i, j in zip(db['Right eye y'], db['Left eye y'])]

def biny(col):
  newcol=[]
  for x in col:
    if x>5:
      newcol.append(1)
    else:
      newcol.append(0)
  return newcol
  

db['A1']=biny(db['A'])
db['C1']=biny(db['C']) 
db['E1']=biny(db['E']) 
db['N1']=biny(db['N']) 
db['O1']=biny(db['O']) 

db.columns.values

def eucl(avgx,avgy,px,py):
    #col=[ sqrt(sum(pow(((x1)-(x2)),2),pow(((y1)-(y2)),2)))  for x1,x2,y1,y2 in zip(avgx,px,avgy,py)]
    col=[sqrt(pow((x-x1),2)+pow((y-y1),2)) for x,x1,y,y1 in zip(avgx,px,avgy,py)]
    return col 
  
db['L1']=eucl(db['avgx'],db['avgy'],db['Right eye x'],db['Right eye y'])
db['L2']=eucl(db['avgx'],db['avgy'],db['Left eye x'],db['Left eye y'])
db['L3']=eucl(db['avgx'],db['avgy'],db['Nose x'],db['Nose y'])
db['L4']=eucl(db['avgx'],db['avgy'],db['Left cheek x'],db['Left cheek y'])
db['L5']=eucl(db['avgx'],db['avgy'],db['Right cheek x'],db['Right cheek y'])
db['L6']=eucl(db['avgx'],db['avgy'],db['Right lip x'],db['Right lip y'])
db['L7']=eucl(db['avgx'],db['avgy'],db['Left lip x'],db['Left lip y'])
db['L8']=eucl(db['avgx'],db['avgy'],db['Chin x'],db['Chin y'])



Xa = db.iloc[:,29:37].values
ya = db.iloc[:,24].values

X_traina, X_testa, y_traina, y_testa = train_test_split(Xa, ya, test_size = 0.1,random_state=50)

X_traina = sc.fit_transform(X_traina)

X_testa = sc.transform(X_testa)

classifiera= Sequential()
#Adding input layer
classifiera.add(Dense(10,kernel_initializer = 'uniform', activation = 'relu',input_dim = 8))
# Adding the hidden layer
classifiera.add(Dense(10,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifiera.add(Dense(30,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifiera.add(Dense(50,kernel_initializer= 'uniform', activation = 'sigmoid'))

#Adding the output layer
classifiera.add(Dense(1,kernel_initializer= 'uniform', activation = 'sigmoid'))

classifiera.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])


classifiera.fit(X_traina, y_traina, epochs=100, batch_size=4)
scores = classifiera.evaluate(X_traina, y_traina)
print("%s: %.2f%%" % (classifiera.metrics_names[1], scores[1]*100))

classifiera.summary()

predictions = classifiera.predict(X_testa)
print(predictions)
rounded = [round(x[0]) for x in predictions]
print(rounded)

y_list=[]
y_list=y_testa.tolist()
report = pd.DataFrame([rounded, y_list]).T
report.columns = ["Prediction", "Actual"]
print(report.head())



report.match = (report.Prediction == report.Actual)
misclassification_ratea = 100 - report.match.sum()/report.shape[0]*100
print(misclassification_ratea)

Xc = db.iloc[:,29:37].values
yc = db.iloc[:,25].values

X_trainc, X_testc, y_trainc, y_testc = train_test_split(Xc, yc, test_size = 0.1,random_state=50)

X_trainc = sc.fit_transform(X_trainc)

X_testc = sc.transform(X_testc)

classifierc= Sequential()
#Adding input layer
classifierc.add(Dense(10,kernel_initializer = 'uniform', activation = 'relu',input_dim = 8))
# Adding the hidden layer
classifierc.add(Dense(10,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifierc.add(Dense(30,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifierc.add(Dense(50,kernel_initializer= 'uniform', activation = 'sigmoid'))

#Adding the output layer
classifierc.add(Dense(1,kernel_initializer= 'uniform', activation = 'sigmoid'))

classifierc.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])


classifierc.fit(X_trainc, y_trainc, epochs=100, batch_size=4)
scores = classifierc.evaluate(X_trainc, y_trainc)
print("%s: %.2f%%" % (classifierc.metrics_names[1], scores[1]*100))

classifierc.summary()

predictions = classifierc.predict(X_testa)
print(predictions)
rounded = [round(x[0]) for x in predictions]
print(rounded)

y_list=y_testc.tolist()
report = pd.DataFrame([rounded, y_list]).T
report.columns = ["Prediction", "Actual"]
print(report.head())



report.match = (report.Prediction == report.Actual)
misclassification_ratec = 100 - report.match.sum()/report.shape[0]*100
print(misclassification_ratec)

Xe = db.iloc[:,29:37].values
ye = db.iloc[:,26].values

X_traine, X_teste, y_traine, y_teste = train_test_split(Xe, ye, test_size = 0.1,random_state=50)

X_traine = sc.fit_transform(X_traine)

X_teste = sc.transform(X_teste)

classifiere= Sequential()
#Adding input layer
classifiere.add(Dense(10,kernel_initializer = 'uniform', activation = 'relu',input_dim = 8))
# Adding the hidden layer
classifiere.add(Dense(10,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifiere.add(Dense(30,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifiere.add(Dense(50,kernel_initializer= 'uniform', activation = 'sigmoid'))

#Adding the output layer
classifiere.add(Dense(1,kernel_initializer= 'uniform', activation = 'sigmoid'))

classifiere.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])


classifiere.fit(X_traine, y_traine, epochs=100, batch_size=4)
scores = classifiere.evaluate(X_traine, y_traine)
print("%s: %.2f%%" % (classifiere.metrics_names[1], scores[1]*100))

classifiere.summary()

predictions = classifiere.predict(X_testa)
print(predictions)
rounded = [round(x[0]) for x in predictions]
print(rounded)

y_list=y_teste.tolist()
report = pd.DataFrame([rounded, y_list]).T
report.columns = ["Prediction", "Actual"]
print(report.head())


report.match = (report.Prediction == report.Actual)
misclassification_ratee = 100 - report.match.sum()/report.shape[0]*100
print(misclassification_ratee)

Xn = db.iloc[:,29:37].values
yn = db.iloc[:,27].values

X_trainn, X_testn, y_trainn, y_testn = train_test_split(Xn, yn, test_size = 0.1,random_state=50)

X_trainn = sc.fit_transform(X_trainn)

X_testn = sc.transform(X_testn)

classifiern= Sequential()
#Adding input layer
classifiern.add(Dense(10,kernel_initializer = 'uniform', activation = 'relu',input_dim = 8))
# Adding the hidden layer
classifiern.add(Dense(10,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifiern.add(Dense(30,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifiern.add(Dense(50,kernel_initializer= 'uniform', activation = 'sigmoid'))

#Adding the output layer
classifiern.add(Dense(1,kernel_initializer= 'uniform', activation = 'sigmoid'))

classifiern.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])


classifiern.fit(X_trainn, y_trainn, epochs=100, batch_size=4)
scores = classifiern.evaluate(X_trainn, y_trainn)
print("%s: %.2f%%" % (classifiern.metrics_names[1], scores[1]*100))

classifiern.summary()

predictions = classifiern.predict(X_testa)
print(predictions)
rounded = [round(x[0]) for x in predictions]
print(rounded)

y_list=y_testn.tolist()
report = pd.DataFrame([rounded, y_list]).T
report.columns = ["Prediction", "Actual"]
print(report.head())


report.match = (report.Prediction == report.Actual)
misclassification_raten = 100 - report.match.sum()/report.shape[0]*100
print(misclassification_raten)

Xo = db.iloc[:,29:37].values
yo = db.iloc[:,28].values

X_traino, X_testo, y_traino, y_testo = train_test_split(Xo, yo, test_size = 0.1,random_state=50)

X_traino = sc.fit_transform(X_traino)

X_testo = sc.transform(X_testo)

classifiero= Sequential()
#Adding input layer
classifiero.add(Dense(10,kernel_initializer = 'uniform', activation = 'relu',input_dim = 8))
# Adding the hidden layer
classifiero.add(Dense(10,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifiero.add(Dense(30,kernel_initializer= 'uniform', activation = 'sigmoid'))
classifiero.add(Dense(50,kernel_initializer= 'uniform', activation = 'sigmoid'))

#Adding the output layer
classifiero.add(Dense(1,kernel_initializer= 'uniform', activation = 'sigmoid'))

classifiero.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])


classifiero.fit(X_traino, y_traino, epochs=100, batch_size=4)
scores = classifiero.evaluate(X_traino, y_traino)
print("%s: %.2f%%" % (classifiero.metrics_names[1], scores[1]*100))

classifiero.summary()

predictions = classifiero.predict(X_testa)
print(predictions)
rounded = [round(x[0]) for x in predictions]
print(rounded)

y_list=y_testo.tolist()
report = pd.DataFrame([rounded, y_list]).T
report.columns = ["Prediction", "Actual"]
print(report.head())


report.match = (report.Prediction == report.Actual)
misclassification_rateo = 100 - report.match.sum()/report.shape[0]*100
print(misclassification_rateo)

def predict(inp):
  ev_li = []
  od_li = []
  for i in inp:
      if (inp.index(i) % 2 == 0):
          ev_li.append(float(i))
      else:
            od_li.append(float(i))
  avgx=(float(ev_li[0])+float(ev_li[1]))*0.5 
  avgy=(float(od_li[0])+float(od_li[1]))*0.5 
  col=[sqrt(pow((avgx-x1),2)+pow((avgy-y1),2)) for x1,y1 in zip(ev_li,od_li)]
  print ("The number of testing set samples: {}".format(len(col)))
  a = array(col)
  a=a.reshape(1, -1)
  b = sc.transform(a)
  output=[]

  predictionsa = classifiera.predict(b)
  roundeda = [round(x[0]) for x in predictionsa]
  output.append(roundeda[0])

  predictionsc = classifierc.predict(b)
  roundedc = [round(x[0]) for x in predictionsc]
  output.append(roundedc[0])

  predictionse = classifiere.predict(b)
  roundede = [round(x[0]) for x in predictionse]
  output.append(roundede[0])

  predictionsn = classifiern.predict(b)
  roundedn = [round(x[0]) for x in predictionsn]
  output.append(roundedn[0])

  predictionso = classifiero.predict(b)
  roundedo = [round(x[0]) for x in predictionso]
  output.append(roundedo[0])
  return(output)

#xcheck=predict([473.20282,606.2982,665.1444,587.36127,579.4854,725.04767,685.2586,681.0132,471.65646,708.78864,667.4258,773.68286,504.284,791.43,587.3779,821.45044])
#xcheck=predict([449.1506,507.0181,625.5188,510.0119,535.5135,614.9829,641.123,585.3011,434.17578,586.8953,621.8794,659.9684,452.7291,660.1891,540.0174,699.05096])

#print(xcheck)

#---------------------------------------------------------------------------------------------------------------------------------------------

@app.route('/')
def display1():
    return "Sam......You're the best :)"

@app.route('/face')
def display2():
	str1=request.args.get('Landmarks')
	str1=str1.replace("%20"," ")
	l=[]
	for i in str1.split():
		print("\n")
		for j in i.split(','):
			if j!='[' and j!=']':
				s=((j.replace('(','')).replace(')',''))
				l.append(float(s))
	op=predict(l[0:16])
	s="According To The Model The Person is : "
	if op[0]>0.5:
		s=s+"\n - Agreeable"
	if op[0]<0.5:
		s=s+"\n - Not Agreeable"
	if op[1]>0.5:
		s=s+"\n - Concious"
	if op[1]<0.5:
		s=s+"\n - Not Concious"
	if op[2]>0.5:
		s=s+"\n - Extrovert"
	if op[2]<0.5:
		s=s+"\n - Introvert"
	if op[3]>0.5:
		s=s+"\n - Neurotic"
	if op[3]<0.5:
		s=s+"\n - Not Neurotic"
	if op[4]>0.5:
		s=s+"\n - Open:"
	if op[4]<0.5:
		s=s+"\n - Not Open"

	return s

@app.route('/text')
def display3():
    str2=request.args.get('TextInp')
    str2=str2.replace("%20"," ")
    return str2

if __name__=='__main__':
    app.run()

